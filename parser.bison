%token TOKEN_EOF
%token TOKEN_PRINT
%token TOKEN_FUNCTION
%token TOKEN_WHILE
%token TOKEN_FOR
%token TOKEN_IF
%token TOKEN_THEN
%token TOKEN_ELSE
%token TOKEN_RETURN
%token TOKEN_LEFT_BRACE
%token TOKEN_RIGHT_BRACE
%token TOKEN_LEFT_PAREN
%token TOKEN_RIGHT_PAREN
%token TOKEN_LEFT_BRACKET
%token TOKEN_RIGHT_BRACKET
%token TOKEN_STRING
%token TOKEN_INTEGER
%token TOKEN_CHAR
%token TOKEN_VOID
%token TOKEN_BOOLEAN
%token TOKEN_ARRAY
%token TOKEN_GE
%token TOKEN_LE
%token TOKEN_EQ
%token TOKEN_NE
%token TOKEN_LT
%token TOKEN_GT
%token TOKEN_AND
%token TOKEN_OR
%token TOKEN_INCREMENT
%token TOKEN_DECREMENT
%token TOKEN_ADD
%token TOKEN_SUBTRACT
%token TOKEN_MULTIPLY
%token TOKEN_DIVIDE
%token TOKEN_MODULUS
%token TOKEN_EXPONENTIATE
%token TOKEN_ASSIGN
%token TOKEN_COMMA
%token TOKEN_COLON
%token TOKEN_SEMICOLON
%token TOKEN_TRUE
%token TOKEN_FALSE
%token TOKEN_CHAR_LITERAL
%token TOKEN_INTEGER_LITERAL
%token TOKEN_STRING_LITERAL
%token TOKEN_IDENTIFIER
%token TOKEN_COMMENT

%{
#include <stuff>

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/
extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/
double parser_result = 0.0;
%}

%%

program: decl_list
	;

decl_list: decl decl_list /*{
		$1 -> next = $2;
		$$ = $1;
}*/
	| /* nothing */

decl: identifier colon type eq expr semicolon
	| identifier colon type semicolon
	| identifier colon type eq left_brace stmt_list right_brace

type: TOKEN_INTEGER
	| void
	| string
	| char
	| boolean
	| array left_bracket opt_expr right_bracket type
	| function type left_paren param_list right_paren
	;

param_list: not_empty_param_list
	| /* nothing */

not_emtpy_param_list: param
	| param comma not_empty_param_list
	;

param:	identifier
	;
/* Redefintions of terminals */
eof: TOKEN_EOF;
print: TOKEN_PRINT;
function: TOKEN_FUNCTION;
for: TOKEN_FOR;
if: TOKEN_IF;
then: TOKEN_THEN;
else: TOKEN_ELSE;
return: TOKEN_RETURN;
left_brace: TOKEN_LEFT_BRACE;
right_brace: TOKEN_RIGHT_BRACE;
left_paren: TOKEN_LEFT_PAREN;
right_paren: TOKEN_RIGHT_PAREN;
left_bracket: TOKEN_LEFT_BRACKET;
right_bracket: TOKEN_RIGHT_BRACKET;
string: TOKEN_STRING;
integer: TOKEN_INTEGER;
char: TOKEN_CHAR;
void: TOKEN_VOID;
boolean: TOKEN_BOOLEAN;
array: TOKEN_ARRAY;
ge: TOKEN_GE;
le: TOKEN_LE;
eq: TOKEN_EQ;
ne: TOKEN_NE;
lt: TOKEN_LT;
gt: TOKEN_GT;
and: TOKEN_AND;
or: TOKEN_OR;
increment: TOKEN_INCREMENT;
decrement: TOKEN_DECREMENT;
add: TOKEN_ADD;
subtract: TOKEN_SUBTRACT;
multiply: TOKEN_MULTIPLY;
divide: TOKEN_DIVIDE;
modulus: TOKEN_MODULUS;
exponentiate: TOKEN_EXPONENTIATE;
assign: TOKEN_ASSIGN;
comma: TOKEN_COMMA;
colon: TOKEN_COLON;
semicolon: TOKEN_SEMICOLON;
true: TOKEN_TRUE;
false: TOKEN_FALSE;
char_literal: TOKEN_CHAR_LITERAL;
integer_literal: TOKEN_INTEGER_LITERAL;
string_literal: TOKEN_STRING_LITERAL;
identifier: TOKEN_IDENTIFIER;
%%

int yyerror(char *str) {
	printf("parse error: %s\n",str);
}
