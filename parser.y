%token TOKEN_PRINT
%token TOKEN_FUNCTION
%token TOKEN_FOR
%token TOKEN_IF
%token TOKEN_ELSE
%token TOKEN_RETURN
%token TOKEN_LEFT_BRACE
%token TOKEN_RIGHT_BRACE
%token TOKEN_LEFT_PAREN
%token TOKEN_RIGHT_PAREN
%token TOKEN_LEFT_BRACKET
%token TOKEN_RIGHT_BRACKET
%token TOKEN_STRING
%token TOKEN_INTEGER
%token TOKEN_CHAR
%token TOKEN_VOID
%token TOKEN_BOOLEAN
%token TOKEN_ARRAY
%token TOKEN_GE
%token TOKEN_LE
%token TOKEN_EQ
%token TOKEN_NE
%token TOKEN_LT
%token TOKEN_GT
%token TOKEN_AND
%token TOKEN_OR
%token TOKEN_NOT
%token TOKEN_INCREMENT
%token TOKEN_DECREMENT
%token TOKEN_ADD
%token TOKEN_SUBTRACT
%token TOKEN_MULTIPLY
%token TOKEN_DIVIDE
%token TOKEN_MODULUS
%token TOKEN_EXPONENTIATE
%token TOKEN_ASSIGN
%token TOKEN_COMMA
%token TOKEN_COLON
%token TOKEN_SEMICOLON
%token TOKEN_TRUE
%token TOKEN_FALSE
%token TOKEN_CHAR_LITERAL
%token TOKEN_INTEGER_LITERAL
%token TOKEN_STRING_LITERAL
%token TOKEN_IDENTIFIER

%{
#include <stdio.h>
#include "decl.h"
#include "stmt.h"
#include "expr.h"
#include "type.h"
#include "param_list.h"

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/
extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/
double parser_result = 0.0;
%}

%%

program: decl_list
	;

decl_list: decl decl_list /*{
		$1 -> next = $2;
		$$ = $1;
}*/
	| /* nothing */
	;

decl: identifier colon type assign expr semicolon
	| identifier colon type semicolon
	| identifier colon type assign left_brace stmt_list right_brace
	;

stmt: open_stmt
	| closed_stmt
	;

closed_stmt: decl
	| expr semicolon
	| return opt_expr semicolon
	| print expr_list semicolon
	| for left_paren opt_expr semicolon opt_expr semicolon opt_expr right_paren closed_stmt
	| if left_paren expr right_paren closed_stmt else closed_stmt
	| left_brace stmt_list right_brace
	;

open_stmt: if left_paren expr right_paren stmt
	| if left_paren expr right_paren closed_stmt else open_stmt
	| for left_paren opt_expr semicolon opt_expr semicolon opt_expr right_paren open_stmt
	;

stmt_list: not_empty_stmt_list
	| /* nothing */
	;

not_empty_stmt_list: stmt not_empty_stmt_list
	| stmt
	;

expr: expr and compare_expr
	| expr or compare_expr
	| compare_expr
	;

compare_expr: add_expr ne add_expr
	| add_expr gt add_expr
	| add_expr ge add_expr
	| add_expr lt add_expr
	| add_expr le add_expr
	| add_expr eq add_expr
	| add_expr
	;

add_expr: add_expr add mul_expr
	| add_expr subtract mul_expr
	| mul_expr
	;

mul_expr: mul_expr multiply expon_expr
	| mul_expr divide expon_expr
	| mul_expr modulus expon_expr
	| expon_expr
	;

expon_expr: neg_expr exponentiate expon_expr
	| neg_expr
	;

neg_expr: subtract incr_expr
	| not incr_expr
	;

incr_expr: primary_expr increment
	| primary_expr decrement
	| primary_expr
	;

opt_expr: expr
	| /* nothing */
	;

expr_list: not_empty_expr_list
	| /* nothing */
	;

not_empty_expr_list: expr comma not_empty_expr_list
	| expr
	;

primary_expr: identifier opt_parenthetical_expr_list
	| integer_literal
	| string_literal
	| char_literal
	| true
	| false
	| left_paren expr right_paren
	| left_brace not_empty_expr_list right_brace
	;

opt_parenthetical_expr_list: left_paren expr_list right_paren
	| /* nothing */
	;

type: integer
	| void
	| string
	| char
	| boolean
	| array left_bracket opt_expr right_bracket type
	| function type left_paren param_list right_paren
	;

param_list: not_empty_param_list
	| /* nothing */
	;

not_empty_param_list: param
	| param comma not_empty_param_list
	;

param:	identifier
	;

/* Redefintions of terminals */
print: TOKEN_PRINT;
function: TOKEN_FUNCTION;
for: TOKEN_FOR;
if: TOKEN_IF;
else: TOKEN_ELSE;
return: TOKEN_RETURN;
left_brace: TOKEN_LEFT_BRACE;
right_brace: TOKEN_RIGHT_BRACE;
left_paren: TOKEN_LEFT_PAREN;
right_paren: TOKEN_RIGHT_PAREN;
left_bracket: TOKEN_LEFT_BRACKET;
right_bracket: TOKEN_RIGHT_BRACKET;
string: TOKEN_STRING;
integer: TOKEN_INTEGER;
char: TOKEN_CHAR;
void: TOKEN_VOID;
boolean: TOKEN_BOOLEAN;
array: TOKEN_ARRAY;
ge: TOKEN_GE;
le: TOKEN_LE;
eq: TOKEN_EQ;
ne: TOKEN_NE;
lt: TOKEN_LT;
gt: TOKEN_GT;
and: TOKEN_AND;
or: TOKEN_OR;
not: TOKEN_NOT;
increment: TOKEN_INCREMENT;
decrement: TOKEN_DECREMENT;
add: TOKEN_ADD;
subtract: TOKEN_SUBTRACT;
multiply: TOKEN_MULTIPLY;
divide: TOKEN_DIVIDE;
modulus: TOKEN_MODULUS;
exponentiate: TOKEN_EXPONENTIATE;
assign: TOKEN_ASSIGN;
comma: TOKEN_COMMA;
colon: TOKEN_COLON;
semicolon: TOKEN_SEMICOLON;
true: TOKEN_TRUE;
false: TOKEN_FALSE;
char_literal: TOKEN_CHAR_LITERAL;
integer_literal: TOKEN_INTEGER_LITERAL;
string_literal: TOKEN_STRING_LITERAL;
identifier: TOKEN_IDENTIFIER;
%%

int yyerror(char *str) {
	printf("parse error: %s\n",str);
}
